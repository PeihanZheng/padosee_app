// ignore_for_file: use_build_context_synchronously

import 'dart:convert';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:dio/dio.dart';
import 'package:dio/src/response.dart' as res;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:padosee/constants/api_routes.dart';
import 'package:padosee/constants/value_notifiers.dart';
import 'package:padosee/models/HttpException.dart';
import 'package:padosee/models/HttpResponse.dart';
import 'package:padosee/models/data_models/user_model.dart';
import 'package:padosee/pages/authentication/login.dart';
import 'package:padosee/pages/dashboard.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../common/methods.dart';

getUserId() async {
  SharedPreferences prefs = await SharedPreferences.getInstance();
  return prefs.getString('uid');
}

getUserDatabase(String uid) async {
  SharedPreferences prefs = await SharedPreferences.getInstance();
  DocumentSnapshot<Map<String, dynamic>> userData = await FirebaseFirestore.instance.collection("usersData").doc(uid).get();
  prefs.setString("user_type", userData["user_type"]);

  return userData;
}

class AuthenticationService {
  UserModel userData = UserModel();
  Dio dio = Dio();
  User? user;

  Stream<User?> get authStateChanges => FirebaseAuth.instance.authStateChanges();

  // void setUserData(UserModel userData) async {
  //   SharedPreferences prefs = await SharedPreferences.getInstance();
  //   final encodedData = json.encode(userData);
  //   if (prefs.containsKey('userdata')) {
  //     prefs.remove('userdata');
  //   }
  //   prefs.setString('userdata', encodedData);
  // }

  Future<HttpResponse?> signInMethod({String? username, String? password}) async {
    const url = ApiRouter.baseUrl + ApiRouter.signInUrl;
    try {
      res.Response response = await dio.post(
        url,
        data: {
          "username": username,
          "password": password,
        },
        options: Options(
          headers: {
            "Accept": "application/json",
            "Content-type": "application/json",
          },
        ),
      );
      if (response.statusCode == 200) {
        if (response.data['status'] == false) {
          errorText = response.data['message'];
          throw HttpException(response.data['message']);
        } else {
          errorText = ValueNotifier('');

          newAccessToken.value = response.data["user"]["accessToken"];
          print("cred::::${newAccessToken.value}");
          // ignore: use_build_context_synchronously
          // ScaffoldMessenger.of(context).showSnackBar(
          //   SnackBar(
          //     behavior: SnackBarBehavior.floating,
          //     padding: const EdgeInsets.symmetric(horizontal: 15, vertical: 15),
          //     shape: RoundedRectangleBorder(
          //       borderRadius: BorderRadius.circular(50),
          //     ),
          //     duration: const Duration(seconds: 3),
          //     content: const Text(
          //       "User Logged in",
          //       textAlign: TextAlign.center,
          //     ),
          //   ),
          // );
          // setUserData(UserModel.fromJson(response.data['user']));
          Get.off(const Dashboard());
        }
      }
    } on DioError catch (error) {
      if (error.response!.statusCode == 400) {
        errorText.value = 'Invalid Password';
        // showSnackbar(context, 'Invalid Password');
      } else if (error.response!.statusCode == 401) {
        errorText.value = 'This account has been disabled, please get in contact with the Administator.';
        // showSnackbar(context, 'This account has been disabled, please get in contact with the Administator.');
      } else if (error.response!.statusCode == 404) {
        errorText.value = 'Username or password is incorrect, Please try again.';
        // showSnackbar(context, 'User is not in the records');
      } else if (error.response!.statusCode == 500) {
        errorText.value = 'Error message generated by the server';
        // showSnackbar(context, 'Error message generated by the server');
      }
    } catch (error) {
      return HttpResponse(status: "false", message: "Somthing wrong please try anagin");
    }
  }

  Future<User?> signIn(BuildContext context, String email, String password) async {
    try {
      UserCredential userCredential = await FirebaseAuth.instance.signInWithEmailAndPassword(email: email, password: password);
      user = userCredential.user;
      SharedPreferences prefs = await SharedPreferences.getInstance();
      if (user != null) {
        errorText.value = "";
        DocumentSnapshot<Map<String, dynamic>> userData = await FirebaseFirestore.instance.collection("usersData").doc(user!.uid).get();
        UserModel userInfo = UserModel(
          id: user!.uid,
          username: userData['username'],
          emailAddress: userData["email_address"],
          role: userData["role"],
        );
        final encodedData = json.encode(userInfo.toJson());
        prefs.setString("userdata", encodedData);
        customSnackbar(message: 'User Logged in', isSuccess: true);
        Get.off(const Dashboard());
      }
    } on FirebaseAuthException catch (e) {
      customSnackbar(message: e.message.toString(), isSuccess: false);
    }
    return user;
  }

  Future<User?> signUp(BuildContext context, UserModel userData, String password) async {
    try {
      UserCredential userCredential =
          await FirebaseAuth.instance.createUserWithEmailAndPassword(email: userData.emailAddress.toString(), password: password);
      user = userCredential.user;
      SharedPreferences prefs = await SharedPreferences.getInstance();
      if (user != null) {
        errorText.value = "";

        final FirebaseMessaging _fcm = FirebaseMessaging.instance;
        final token = await _fcm.getToken();

        final data = UserModel(
          id: user!.uid,
          username: userData.username,
          emailAddress: userData.emailAddress,
          role: "secondary",
          fcmToken: token,
        );

        FirebaseFirestore.instance.collection("usersData").doc(user!.uid).set(data.toJson());
        customSnackbar(message: 'User Registered Successfully', isSuccess: true);
        Get.off(const LoginScreen());
      }
    } on FirebaseAuthException catch (e) {
      customSnackbar(message: e.message.toString(), isSuccess: false);
    }
    return user;
  }

  // Future<void> signOut(BuildContext context) async {
  //   SharedPreferences prefs = await SharedPreferences.getInstance();
  //   prefs.remove('cameraData');
  //   // prefs.remove('userdata');
  //   Navigator.of(context).pushReplacement(
  //     MaterialPageRoute(
  //       builder: (context) => const LoginScreen(),
  //     ),
  //   );
  // }

  Future<void> signOut(BuildContext context) async {
    await FirebaseAuth.instance.signOut();
    SharedPreferences prefs = await SharedPreferences.getInstance();
    prefs.remove("primaryUserName");
    prefs.remove("userdata");
    Get.off(const LoginScreen());
  }

  User? getUser() {
    try {
      return FirebaseAuth.instance.currentUser;
    } on FirebaseAuthException {
      return null;
    }
  }
}
